; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9030 

	TITLE	misccode\gla_stuff.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CL@CKKKHOFG@Failed?5to?5Create?5OpenGL?5Renderin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BNKHHAOG@GLASS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJDLIPAJ@Couldn?8t?5Register?5Window?5Class?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MOBNEOLM@TEST?5?$CIfs?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OIKJMBFP@TEST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GKGAPFJA@TEST?5?$CI?$CBfs?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?glaExit@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setupGL@@YAPAUHGLRC__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MainWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?glaStartup@@YAXHIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?glaShutdown@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?glaCls@@YAXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?glaBlit@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pfd@?1??setupGL@@YAPAUHGLRC__@@H@Z@4UtagPIXELFORMATDESCRIPTOR@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_pd@@3PAMA					; _pd
PUBLIC	?_pu@@3PAMA					; _pu
PUBLIC	?_pv@@3PAMA					; _pv
PUBLIC	?_pu2@@3PAMA					; _pu2
PUBLIC	?_pv2@@3PAMA					; _pv2
PUBLIC	?maindc@@3PAUHDC__@@A				; maindc
PUBLIC	?mainwindow@@3PAUHWND__@@A			; mainwindow
_BSS	SEGMENT
?_pd@@3PAMA DD	01H DUP (?)				; _pd
?_pu@@3PAMA DD	01H DUP (?)				; _pu
?_pv@@3PAMA DD	01H DUP (?)				; _pv
?_pu2@@3PAMA DD	01H DUP (?)				; _pu2
?_pv2@@3PAMA DD	01H DUP (?)				; _pv2
_done	DD	01H DUP (?)
_ready	DD	01H DUP (?)
_g_kbhit DD	01H DUP (?)
_g_getch DD	01H DUP (?)
?maindc@@3PAUHDC__@@A DD 01H DUP (?)			; maindc
?mainwindow@@3PAUHWND__@@A DD 01H DUP (?)		; mainwindow
_BSS	ENDS
PUBLIC	?glaExit@@YAHXZ					; glaExit
; Function compile flags: /Ogty
; File d:\code\prj64k\glass (eventad)\misccode\gla_stuff.cpp
;	COMDAT ?glaExit@@YAHXZ
_TEXT	SEGMENT
?glaExit@@YAHXZ PROC NEAR				; glaExit, COMDAT

; 22   : 	return g_kbhit;

	mov	eax, DWORD PTR _g_kbhit

; 23   : };

	ret	0
?glaExit@@YAHXZ ENDP					; glaExit
_TEXT	ENDS
PUBLIC	?setupGL@@YAPAUHGLRC__@@H@Z			; setupGL
EXTRN	__imp__wglCreateContext@4:NEAR
EXTRN	__imp__wglDeleteContext@4:NEAR
EXTRN	__imp__wglMakeCurrent@8:NEAR
EXTRN	__imp__SetPixelFormat@12:NEAR
EXTRN	__imp__ChoosePixelFormat@8:NEAR
_BSS	SEGMENT
_hDC	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?pfd@?1??setupGL@@YAPAUHGLRC__@@H@Z@4UtagPIXELFORMATDESCRIPTOR@@A
_DATA	SEGMENT
?pfd@?1??setupGL@@YAPAUHGLRC__@@H@Z@4UtagPIXELFORMATDESCRIPTOR@@A DW 028H ; `setupGL'::`2'::pfd
	DW	01H
	DD	025H
	DB	00H
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?setupGL@@YAPAUHGLRC__@@H@Z
_TEXT	SEGMENT
_bpp$ = 8
?setupGL@@YAPAUHGLRC__@@H@Z PROC NEAR			; setupGL, COMDAT

; 26   :     static PIXELFORMATDESCRIPTOR pfd = {
; 27   :         sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd
; 28   :         1,                              // version number
; 29   :         PFD_DRAW_TO_WINDOW              // support window
; 30   :         |  PFD_SUPPORT_OPENGL           // support OpenGL
; 31   :         |  PFD_DOUBLEBUFFER ,           // double buffered
; 32   :         PFD_TYPE_RGBA,                  // RGBA type
; 33   :         32,                             // 16-bit color depth
; 34   :         0, 0, 0, 0, 0, 0,               // color bits ignored
; 35   :         16,                             // no alpha buffer
; 36   :         0,                              // shift bit ignored
; 37   :         0,                              // no accumulation buffer
; 38   :         0, 0, 0, 0,                     // accum bits ignored
; 39   :         16,                             // 16-bit z-buffer      
; 40   :         0,                              // no stencil buffer
; 41   :         0,                              // no auxiliary buffer
; 42   :         PFD_MAIN_PLANE,                 // main layer
; 43   :         0,                              // reserved
; 44   :         0, 0, 0                         // layer masks ignored
; 45   :     };
; 46   :     int  pixelFormat;
; 47   :     HGLRC rv = 0;
; 48   : 
; 49   :     pixelFormat = ChoosePixelFormat(hDC, &pfd);

	mov	eax, DWORD PTR _hDC
	push	esi
	push	OFFSET FLAT:?pfd@?1??setupGL@@YAPAUHGLRC__@@H@Z@4UtagPIXELFORMATDESCRIPTOR@@A
	push	eax
	xor	esi, esi
	call	DWORD PTR __imp__ChoosePixelFormat@8

; 50   :     if ( pixelFormat ) {

	test	eax, eax
	je	SHORT $L20057

; 51   :         if ( SetPixelFormat(hDC, pixelFormat, &pfd) ) {

	mov	ecx, DWORD PTR _hDC
	push	OFFSET FLAT:?pfd@?1??setupGL@@YAPAUHGLRC__@@H@Z@4UtagPIXELFORMATDESCRIPTOR@@A
	push	eax
	push	ecx
	call	DWORD PTR __imp__SetPixelFormat@12
	test	eax, eax
	je	SHORT $L20057

; 52   :             rv = wglCreateContext( hDC );

	mov	edx, DWORD PTR _hDC
	push	edx
	call	DWORD PTR __imp__wglCreateContext@4
	mov	esi, eax

; 53   :             if ( rv ) {

	test	esi, esi
	je	SHORT $L20057

; 54   :                 if ( !wglMakeCurrent( hDC, rv ) ) {

	mov	eax, DWORD PTR _hDC
	push	esi
	push	eax
	call	DWORD PTR __imp__wglMakeCurrent@8
	test	eax, eax
	jne	SHORT $L20057

; 55   :                     wglDeleteContext( rv );

	push	esi
	call	DWORD PTR __imp__wglDeleteContext@4

; 56   :                     rv = 0;

	xor	eax, eax
	pop	esi

; 62   : }

	ret	0
$L20057:

; 57   :                 }
; 58   :             }
; 59   :         }
; 60   :     }
; 61   :     return rv;

	mov	eax, esi
	pop	esi

; 62   : }

	ret	0
?setupGL@@YAPAUHGLRC__@@H@Z ENDP			; setupGL
_TEXT	ENDS
PUBLIC	?MainWndProc@@YGJPAUHWND__@@IIJ@Z		; MainWndProc
PUBLIC	??_C@_0CL@CKKKHOFG@Failed?5to?5Create?5OpenGL?5Renderin@ ; `string'
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__DestroyWindow@4:NEAR
EXTRN	?Error@@YAXPAD@Z:NEAR				; Error
EXTRN	__imp__SetTimer@16:NEAR
_BSS	SEGMENT
_glRC	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CL@CKKKHOFG@Failed?5to?5Create?5OpenGL?5Renderin@
CONST	SEGMENT
??_C@_0CL@CKKKHOFG@Failed?5to?5Create?5OpenGL?5Renderin@ DB 'Failed to Cr'
	DB	'eate OpenGL Rendering Context.', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MainWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8
_uMsg$ = 12
_wParam$ = 16
_lParam$ = 20
?MainWndProc@@YGJPAUHWND__@@IIJ@Z PROC NEAR		; MainWndProc, COMDAT

; 71   :     LONG    lRet = 1;
; 72   : 	extern unsigned int uiWheelMessage;
; 73   : 
; 74   : //	if ( uMsg == uiWheelMessage )
; 75   : //		uMsg = WM_MOUSEWHEEL;
; 76   : 
; 77   :     switch (uMsg)
; 78   :     {

	mov	ecx, DWORD PTR _uMsg$[esp-4]
	mov	eax, ecx
	dec	eax
	push	edi
	mov	edi, 1
	je	SHORT $L19923
	dec	eax
	je	SHORT $L19927
	sub	eax, 254				; 000000feH
	je	SHORT $L19926
	pop	edi

; 116  :         }
; 117  :         break;
; 118  : 
; 119  :     	default:
; 120  :             /* pass all unhandled messages to DefWindowProc */
; 121  :             lRet = DefWindowProc (hWnd, uMsg, wParam, lParam);

	mov	DWORD PTR _uMsg$[esp-4], ecx
	jmp	DWORD PTR __imp__DefWindowProcA@16
$L19926:

; 88   : 			break;
; 89   : 
; 90   : 		case WM_KEYDOWN:
; 91   : 			g_kbhit	= 1;

	mov	DWORD PTR _g_kbhit, edi

; 122  : 			break;
; 123  :     }
; 124  : 
; 125  :     /* return 1 if handled message, 0 if not */
; 126  :     return lRet;

	mov	eax, edi
	pop	edi

; 127  : }

	ret	16					; 00000010H
$L19927:

; 92   : 			break;
; 93   : /*
; 94   : 		case WM_MOVE:
; 95   : //			window_x = (int) LOWORD(lParam);
; 96   : //			window_y = (int) HIWORD(lParam);
; 97   : //			VID_UpdateWindowStatus ();
; 98   : 			break;
; 99   : 		
; 100  : 		case WM_SYSCHAR:
; 101  : 			// keep Alt-Space from happening
; 102  : 			break;
; 103  : 
; 104  :     	case WM_SIZE:
; 105  :             break;
; 106  : 
; 107  :    	    case WM_CLOSE:
; 108  : 	        break;
; 109  : */
; 110  :    	    case WM_DESTROY:
; 111  :         {
; 112  : //			if (dibwindow)
; 113  : //				DestroyWindow (dibwindow);
; 114  : 
; 115  :             PostQuitMessage (0);

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 122  : 			break;
; 123  :     }
; 124  : 
; 125  :     /* return 1 if handled message, 0 if not */
; 126  :     return lRet;

	mov	eax, edi
	pop	edi

; 127  : }

	ret	16					; 00000010H
$L19923:
	push	esi

; 79   : 		case WM_CREATE:
; 80   : 			hDC  = GetDC( hWnd );

	mov	esi, DWORD PTR _hWnd$[esp+4]
	push	esi
	call	DWORD PTR __imp__GetDC@4

; 81   : 			glRC = setupGL( lParam );

	mov	ecx, DWORD PTR _lParam$[esp+4]
	push	ecx
	mov	DWORD PTR _hDC, eax
	call	?setupGL@@YAPAUHGLRC__@@H@Z		; setupGL
	add	esp, 4

; 82   : 			ready = 1;
; 83   : 			if ( !glRC ) {

	test	eax, eax
	mov	DWORD PTR _glRC, eax
	mov	DWORD PTR _ready, edi
	jne	SHORT $L19924

; 84   : 				DestroyWindow( hWnd );

	push	esi
	call	DWORD PTR __imp__DestroyWindow@4

; 85   : 	            Error( "Failed to Create OpenGL Rendering Context." );           

	push	OFFSET FLAT:??_C@_0CL@CKKKHOFG@Failed?5to?5Create?5OpenGL?5Renderin@
	call	?Error@@YAXPAD@Z			; Error
	add	esp, 4
$L19924:

; 86   : 			}
; 87   : 			SetTimer( hWnd, 1, 1, NULL );

	push	0
	push	edi
	push	edi
	push	esi
	call	DWORD PTR __imp__SetTimer@16
	pop	esi

; 122  : 			break;
; 123  :     }
; 124  : 
; 125  :     /* return 1 if handled message, 0 if not */
; 126  :     return lRet;

	mov	eax, edi
	pop	edi

; 127  : }

	ret	16					; 00000010H
?MainWndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; MainWndProc
_TEXT	ENDS
PUBLIC	?glaStartup@@YAXHIII@Z				; glaStartup
PUBLIC	??_C@_05BNKHHAOG@GLASS?$AA@			; `string'
PUBLIC	??_C@_0BP@GJDLIPAJ@Couldn?8t?5Register?5Window?5Class?$AA@ ; `string'
PUBLIC	??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@ ; `string'
PUBLIC	??_C@_09MOBNEOLM@TEST?5?$CIfs?$CJ?$AA@		; `string'
PUBLIC	??_C@_04OIKJMBFP@TEST?$AA@			; `string'
PUBLIC	??_C@_0L@GKGAPFJA@TEST?5?$CI?$CBfs?$CJ?$AA@	; `string'
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
EXTRN	__imp__UpdateWindow@4:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__ChangeDisplaySettingsA@8:NEAR
EXTRN	__imp__AdjustWindowRectEx@16:NEAR
EXTRN	__imp__EnumDisplaySettingsA@12:NEAR
EXTRN	__imp__GetModuleHandleA@4:NEAR
EXTRN	__imp__glClearDepth@8:NEAR
EXTRN	__imp__glViewport@16:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
EXTRN	__fltused:NEAR
_BSS	SEGMENT
_hwnd	DD	01H DUP (?)
_time1	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05BNKHHAOG@GLASS?$AA@
CONST	SEGMENT
??_C@_05BNKHHAOG@GLASS?$AA@ DB 'GLASS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJDLIPAJ@Couldn?8t?5Register?5Window?5Class?$AA@
CONST	SEGMENT
??_C@_0BP@GJDLIPAJ@Couldn?8t?5Register?5Window?5Class?$AA@ DB 'Couldn''t '
	DB	'Register Window Class', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@
CONST	SEGMENT
??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@ DB 'glAss | psikorp 20'
	DB	'00', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOBNEOLM@TEST?5?$CIfs?$CJ?$AA@
CONST	SEGMENT
??_C@_09MOBNEOLM@TEST?5?$CIfs?$CJ?$AA@ DB 'TEST (fs)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OIKJMBFP@TEST?$AA@
CONST	SEGMENT
??_C@_04OIKJMBFP@TEST?$AA@ DB 'TEST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKGAPFJA@TEST?5?$CI?$CBfs?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@GKGAPFJA@TEST?5?$CI?$CBfs?$CJ?$AA@ DB 'TEST (!fs)', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?glaStartup@@YAXHIII@Z
_TEXT	SEGMENT
_r$19958 = -212
_wc$ = -196
_devmode$19947 = -156
_fullscreen$ = 8
_w$ = 12
_h$ = 16
_bpp$ = 20
?glaStartup@@YAXHIII@Z PROC NEAR			; glaStartup, COMDAT

; 129  : void glaStartup( int fullscreen, unsigned int w, unsigned int h, unsigned int bpp ) {

	sub	esp, 212				; 000000d4H
	push	ebx
	push	ebp
	push	esi

; 130  : 
; 131  : 	WNDCLASS   wc;
; 132  : 
; 133  :     done      = FALSE;

	xor	ebp, ebp
	push	edi

; 134  : 
; 135  :     wc.style         = 0;
; 136  :     wc.lpfnWndProc   = (WNDPROC)MainWndProc;
; 137  :     wc.cbClsExtra    = 0;
; 138  :     wc.cbWndExtra    = 0;
; 139  :     wc.hInstance     = GetModuleHandle(NULL);

	mov	edi, DWORD PTR __imp__GetModuleHandleA@4
	push	ebp
	mov	DWORD PTR _done, ebp
	mov	DWORD PTR _wc$[esp+232], ebp
	mov	DWORD PTR _wc$[esp+236], OFFSET FLAT:?MainWndProc@@YGJPAUHWND__@@IIJ@Z ; MainWndProc
	mov	DWORD PTR _wc$[esp+240], ebp
	mov	DWORD PTR _wc$[esp+244], ebp
	call	edi

; 140  :     wc.hIcon         = NULL;//LoadIcon (hInstance, "3dFXTest");
; 141  :     wc.hCursor       = LoadCursor( NULL, IDC_ARROW );

	push	32512					; 00007f00H
	push	ebp
	mov	DWORD PTR _wc$[esp+252], eax
	mov	DWORD PTR _wc$[esp+256], ebp
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[esp+252], eax

; 142  :     wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
; 143  :     wc.lpszMenuName  = NULL;
; 144  :     wc.lpszClassName = "GLASS";
; 145  :     
; 146  :     if ( !RegisterClass( &wc ) )

	lea	eax, DWORD PTR _wc$[esp+228]
	push	eax
	mov	DWORD PTR _wc$[esp+260], 6
	mov	DWORD PTR _wc$[esp+264], ebp
	mov	DWORD PTR _wc$[esp+268], OFFSET FLAT:??_C@_05BNKHHAOG@GLASS?$AA@
	call	DWORD PTR __imp__RegisterClassA@4
	test	ax, ax
	jne	SHORT $L19942

; 147  : 		Error( "Couldn't Register Window Class" );

	push	OFFSET FLAT:??_C@_0BP@GJDLIPAJ@Couldn?8t?5Register?5Window?5Class?$AA@
	call	?Error@@YAXPAD@Z			; Error
	add	esp, 4
$L19942:

; 148  : 
; 149  : 	if( fullscreen ) {

	cmp	DWORD PTR _fullscreen$[esp+224], ebp
	je	$L19944

; 150  : 
; 151  : 	    hwnd = CreateWindow( "GLASS",
; 152  : 						"glAss | psikorp 2000",
; 153  : 						WS_POPUP,
; 154  : 						0, 0, w, h,
; 155  : 						NULL,
; 156  : 						NULL,
; 157  : 						GetModuleHandle(NULL),
; 158  : 						NULL);

	push	ebp
	push	ebp
	call	edi
	mov	ebx, DWORD PTR _h$[esp+228]
	mov	esi, DWORD PTR _w$[esp+228]
	push	eax
	push	ebp
	push	ebp
	push	ebx
	push	esi
	push	ebp
	push	ebp
	push	-2147483648				; 80000000H
	push	OFFSET FLAT:??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@
	push	OFFSET FLAT:??_C@_05BNKHHAOG@GLASS?$AA@
	push	ebp
	call	DWORD PTR __imp__CreateWindowExA@48

; 159  : 
; 160  : 		Error( "TEST (fs)" );

	push	OFFSET FLAT:??_C@_09MOBNEOLM@TEST?5?$CIfs?$CJ?$AA@
	mov	DWORD PTR _hwnd, eax
	call	?Error@@YAXPAD@Z			; Error

; 161  : 
; 162  : 		DEVMODE	devmode;
; 163  : 
; 164  : 		int		modenum;
; 165  : 		BOOL	stat;
; 166  : 
; 167  : 		// enumerate >8 bpp modes
; 168  : 
; 169  : 		Error( "TEST" );

	push	OFFSET FLAT:??_C@_04OIKJMBFP@TEST?$AA@
	call	?Error@@YAXPAD@Z			; Error
	add	esp, 8
$L19951:

; 170  : 
; 171  : 		modenum = 0;
; 172  : 		do
; 173  : 		{
; 174  : 			stat = EnumDisplaySettings (NULL, modenum, &devmode);

	lea	ecx, DWORD PTR _devmode$19947[esp+228]
	push	ecx
	push	ebp
	push	0
	call	DWORD PTR __imp__EnumDisplaySettingsA@12
	mov	edi, eax

; 175  : 
; 176  : 			//
; 177  : 				
; 178  : 			if ((devmode.dmBitsPerPel == 32) &&
; 179  : 				(devmode.dmPelsWidth == w) &&
; 180  : 				(devmode.dmPelsHeight == h) ) {

	cmp	DWORD PTR _devmode$19947[esp+332], 32	; 00000020H
	jne	SHORT $L20066
	cmp	DWORD PTR _devmode$19947[esp+336], esi
	jne	SHORT $L20066
	cmp	DWORD PTR _devmode$19947[esp+340], ebx
	jne	SHORT $L20066

; 181  : 				devmode.dmFields = DM_BITSPERPEL |
; 182  : 									DM_PELSWIDTH |
; 183  : 									DM_PELSHEIGHT;
; 184  : 
; 185  : 				if (ChangeDisplaySettings (&devmode, CDS_TEST | CDS_FULLSCREEN) ==
; 186  : 						DISP_CHANGE_SUCCESSFUL)

	push	6
	lea	edx, DWORD PTR _devmode$19947[esp+232]
	push	edx
	mov	DWORD PTR _devmode$19947[esp+276], 1835008 ; 001c0000H
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	test	eax, eax
	jne	SHORT $L20066

; 187  : 				{
; 188  : 					stat = 0;

	xor	edi, edi
$L20066:

; 189  : 				};
; 190  : 
; 191  : 			}
; 192  : 
; 193  : 			modenum++;

	inc	ebp

; 194  : 		} while (stat);

	test	edi, edi
	jne	SHORT $L19951

; 195  : 
; 196  : 		ChangeDisplaySettings (&devmode, CDS_FULLSCREEN );

	push	4
	lea	eax, DWORD PTR _devmode$19947[esp+232]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 197  : 
; 198  : 	} else {

	xor	ebp, ebp
	jmp	$L19956
$L19944:

; 199  : 
; 200  : 		int ws = WS_DLGFRAME | WS_MAXIMIZE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
; 201  : 
; 202  : 		RECT r;
; 203  : 		r.top = (GetSystemMetrics(SM_CYSCREEN)-h)/2;

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	1
	call	esi
	mov	ebx, DWORD PTR _h$[esp+224]
	sub	eax, ebx
	shr	eax, 1

; 204  : 		r.left = (GetSystemMetrics(SM_CXSCREEN)-w)/2;

	push	ebp
	mov	DWORD PTR _r$19958[esp+236], eax
	call	esi
	mov	esi, DWORD PTR _w$[esp+224]

; 205  : 		r.right = r.left + w;
; 206  : 		r.bottom = r.top + h;

	mov	ecx, DWORD PTR _r$19958[esp+232]

; 207  : 		AdjustWindowRectEx( &r, ws, FALSE, 0);

	push	ebp
	sub	eax, esi
	shr	eax, 1
	push	ebp
	mov	DWORD PTR _r$19958[esp+236], eax
	push	121634816				; 07400000H
	lea	edx, DWORD PTR _r$19958[esp+240]
	add	eax, esi
	add	ecx, ebx
	push	edx
	mov	DWORD PTR _r$19958[esp+252], eax
	mov	DWORD PTR _r$19958[esp+256], ecx
	call	DWORD PTR __imp__AdjustWindowRectEx@16

; 208  : 
; 209  : 		hwnd = CreateWindow ("GLASS",
; 210  : 							"glAss | psikorp 2000",
; 211  : 							ws,
; 212  : 							r.left, r.top, r.right-r.left, r.bottom-r.top,
; 213  : 							NULL,
; 214  : 							NULL,
; 215  : 							GetModuleHandle(NULL),
; 216  : 							NULL);

	push	ebp
	push	ebp
	call	edi
	mov	ecx, DWORD PTR _r$19958[esp+244]
	mov	edx, DWORD PTR _r$19958[esp+240]
	push	eax
	mov	eax, DWORD PTR _r$19958[esp+240]
	push	ebp
	push	ebp
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _r$19958[esp+248]
	sub	edx, ecx
	push	edx
	push	eax
	push	ecx
	push	121634816				; 07400000H
	push	OFFSET FLAT:??_C@_0BF@OCONGMKI@glAss?5?$HM?5psikorp?52000?$AA@
	push	OFFSET FLAT:??_C@_05BNKHHAOG@GLASS?$AA@
	push	ebp
	call	DWORD PTR __imp__CreateWindowExA@48

; 217  : 
; 218  : Error( "TEST (!fs)" );

	push	OFFSET FLAT:??_C@_0L@GKGAPFJA@TEST?5?$CI?$CBfs?$CJ?$AA@
	mov	DWORD PTR _hwnd, eax
	call	?Error@@YAXPAD@Z			; Error
	add	esp, 4
$L19956:

; 219  : 
; 220  : 	};
; 221  : 
; 222  : 	ShowWindow (hwnd, SW_SHOWDEFAULT);

	mov	eax, DWORD PTR _hwnd
	push	10					; 0000000aH
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 223  : 	UpdateWindow (hwnd);

	mov	ecx, DWORD PTR _hwnd
	push	ecx
	call	DWORD PTR __imp__UpdateWindow@4

; 224  : 
; 225  :     glViewport(0, 0, w, h);

	push	ebx
	push	esi
	push	ebp
	push	ebp
	call	DWORD PTR __imp__glViewport@16

; 226  : 	glClearDepth( 100 );

	push	1079574528				; 40590000H
	push	ebp
	call	DWORD PTR __imp__glClearDepth@8

; 227  : 
; 228  : 	time1 = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _time1, eax
	pop	ebx

; 229  : };

	add	esp, 212				; 000000d4H
	ret	0
?glaStartup@@YAXHIII@Z ENDP				; glaStartup
_TEXT	ENDS
PUBLIC	?glaShutdown@@YAXXZ				; glaShutdown
EXTRN	__imp__wglGetCurrentContext@0:NEAR
EXTRN	__imp__wglGetCurrentDC@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?glaShutdown@@YAXXZ
_TEXT	SEGMENT
?glaShutdown@@YAXXZ PROC NEAR				; glaShutdown, COMDAT

; 231  : void glaShutdown() {

	push	esi

; 232  :    	HGLRC hRC;
; 233  :    	HDC	  hDC;
; 234  : 
; 235  : 	hRC = wglGetCurrentContext();

	call	DWORD PTR __imp__wglGetCurrentContext@0
	mov	esi, eax

; 236  :    	hDC = wglGetCurrentDC();

	call	DWORD PTR __imp__wglGetCurrentDC@0

; 237  : 
; 238  : 	wglMakeCurrent(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__wglMakeCurrent@8

; 239  : 
; 240  : 	if (hRC)

	test	esi, esi
	je	SHORT $L19964

; 241  :    	    wglDeleteContext(hRC);

	push	esi
	call	DWORD PTR __imp__wglDeleteContext@4
$L19964:

; 242  : 
; 243  : //	if (hDC && dibwindow)
; 244  : //		ReleaseDC(dibwindow, hDC);
; 245  : 
; 246  : //	if (modestate == MS_FULLDIB)
; 247  : 		ChangeDisplaySettings (NULL, 0);

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	pop	esi

; 248  : 
; 249  : //	if (maindc && dibwindow)
; 250  : //		ReleaseDC (dibwindow, maindc);
; 251  : 	
; 252  : //	DestroyWindow( hwnd );
; 253  : //	ChangeDisplaySettings(NULL, 0);
; 254  : };

	ret	0
?glaShutdown@@YAXXZ ENDP				; glaShutdown
_TEXT	ENDS
PUBLIC	?glaCls@@YAXM@Z					; glaCls
PUBLIC	__real@00000000
EXTRN	__imp__glLoadIdentity@0:NEAR
EXTRN	__imp__glPopMatrix@0:NEAR
EXTRN	__imp__glPushMatrix@0:NEAR
EXTRN	__imp__glBegin@4:NEAR
EXTRN	__imp__glBlendFunc@8:NEAR
EXTRN	__imp__glClear@4:NEAR
EXTRN	__imp__glClearColor@16:NEAR
EXTRN	__imp__glVertex3f@12:NEAR
EXTRN	__imp__glColor4f@16:NEAR
EXTRN	__imp__glDisable@4:NEAR
EXTRN	__imp__glEnable@4:NEAR
EXTRN	__imp__glEnd@0:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?glaCls@@YAXM@Z
_TEXT	SEGMENT
_mb$ = 8
?glaCls@@YAXM@Z PROC NEAR				; glaCls, COMDAT

; 257  : 	if( mb>0 ) {

	fld	DWORD PTR _mb$[esp-4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L19968
	push	esi

; 258  : 		glEnable( GL_BLEND );

	mov	esi, DWORD PTR __imp__glEnable@4
	push	3042					; 00000be2H
	call	esi

; 259  : 		glEnable( GL_ALPHA );

	push	6406					; 00001906H
	call	esi

; 260  : 		glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8

; 261  : 		glPushMatrix();

	call	DWORD PTR __imp__glPushMatrix@0

; 262  : 		glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 263  : 		glBegin( GL_QUADS );

	push	7
	call	DWORD PTR __imp__glBegin@4

; 264  : 		glColor4f( 0.0f, 0.0f, 0.0f, mb );

	mov	eax, DWORD PTR _mb$[esp]
	push	eax
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__glColor4f@16

; 265  : 		glVertex3f( -1, -1.0f, 0 );

	mov	esi, DWORD PTR __imp__glVertex3f@12
	push	0
	push	-1082130432				; bf800000H
	push	-1082130432				; bf800000H
	call	esi

; 266  : 		glVertex3f(  1, -1.0f, 0 );

	push	0
	push	-1082130432				; bf800000H
	push	1065353216				; 3f800000H
	call	esi

; 267  : 		glVertex3f(  1,  1.0f, 0 );

	push	0
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	esi

; 268  : 		glVertex3f( -1,  1.0f, 0 );

	push	0
	push	1065353216				; 3f800000H
	push	-1082130432				; bf800000H
	call	esi

; 269  : 		glEnd();

	call	DWORD PTR __imp__glEnd@0

; 270  : 		glPopMatrix();

	call	DWORD PTR __imp__glPopMatrix@0

; 271  : 		glDisable( GL_ALPHA );

	mov	esi, DWORD PTR __imp__glDisable@4
	push	6406					; 00001906H
	call	esi

; 272  : 		glDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	esi

; 273  : 		glClear( GL_DEPTH_BUFFER_BIT );

	push	256					; 00000100H
	call	DWORD PTR __imp__glClear@4
	pop	esi

; 277  : 	};
; 278  : };

	ret	0
$L19968:

; 274  : 	} else {
; 275  : 		glClearColor( 0,0,0,0 );

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__glClearColor@16

; 276  : 		glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4

; 277  : 	};
; 278  : };

	ret	0
?glaCls@@YAXM@Z ENDP					; glaCls
_TEXT	ENDS
PUBLIC	?glaBlit@@YAXXZ					; glaBlit
EXTRN	__imp__PeekMessageA@20:NEAR
EXTRN	__imp__SwapBuffers@4:NEAR
EXTRN	__imp__glFinish@0:NEAR
EXTRN	__imp__glFlush@0:NEAR
EXTRN	__imp__GetMessageA@16:NEAR
EXTRN	__imp__TranslateMessage@4:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?glaBlit@@YAXXZ
_TEXT	SEGMENT
_msg$ = -28
?glaBlit@@YAXXZ PROC NEAR				; glaBlit, COMDAT

; 286  : 
; 287  : 	if( hDC == NULL || hwnd == NULL ) return;

	mov	eax, DWORD PTR _hDC
	sub	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $L19975
	mov	eax, DWORD PTR _hwnd
	test	eax, eax
	je	SHORT $L19975

; 288  : 
; 289  : 	glFinish();

	call	DWORD PTR __imp__glFinish@0

; 290  : 	glFlush();

	call	DWORD PTR __imp__glFlush@0

; 291  : 	SwapBuffers( hDC );

	mov	eax, DWORD PTR _hDC
	push	eax
	call	DWORD PTR __imp__SwapBuffers@4

; 292  : 
; 293  : #ifdef SHOWFPS
; 294  : 	DWORD tix = GetTickCount() - lastblittime;
; 295  : 	float ftix = 1000.0f / (float)tix;// / 1000.0f;
; 296  : 
; 297  : 	float t = glaTime();
; 298  : 
; 299  : 	int a0 = (int)(t*100);
; 300  : 	int a1 = ((int)(t*10000.0f))%1000;
; 301  : 
; 302  : 	char str[40];
; 303  : 	float fps = ftix;
; 304  : 	wsprintf( str, "%06d - ~%d fps", (int)a0, (long)fps );
; 305  : 	SetWindowText( hwnd, str );
; 306  : 	idiot ++;
; 307  : #endif
; 308  : 
; 309  : 	MSG msg;
; 310  : 	if( PeekMessage( &msg, 0, 0, 0, PM_NOREMOVE ) ) {

	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _msg$[esp+44]
	push	ecx
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	SHORT $L19975

; 311  : 		GetMessage( &msg, 0, 0, 0 );

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _msg$[esp+40]
	push	edx
	call	DWORD PTR __imp__GetMessageA@16

; 312  : 		TranslateMessage( &msg );

	lea	eax, DWORD PTR _msg$[esp+28]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4

; 313  : 		DispatchMessage( &msg );

	lea	ecx, DWORD PTR _msg$[esp+28]
	push	ecx
	call	DWORD PTR __imp__DispatchMessageA@4
$L19975:

; 314  : 	};
; 315  : 
; 316  : #ifdef SHOWFPS
; 317  : 	lastblittime = GetTickCount();
; 318  : #endif
; 319  : 
; 320  : };

	add	esp, 28					; 0000001cH
	ret	0
?glaBlit@@YAXXZ ENDP					; glaBlit
_TEXT	ENDS
END
